// boot实现
c02.02 用汇编代码接管控制权
c02.03 第一个汇编程序
c02.04 使用BIOS中断显示字符
c02.05 使用BIOS中断读取磁盘
c02.06 进入C语言环境并跳到loader

// loader实现
c03.01 利用内联汇编显示字符串
c03.02 检测内存信息
c03.03 切换至图形显示模式
c03.05 切换至32位保护模式
c03.06 创建内核工程
c03.07 使用LBA读取内核
c03.08 使用ELF文件格式的内核

// 中断系统配置
c04.01 创建GDT表及其表项
c04.01 重新加载GDT

在这里把exception_frame_t去掉，后面加
c04.08 添加其它所有的异常处理
c04.09 配置并启动定时器
c04.10 开启定时器中断

c05.01 创建日志打印接口
c05.02 实现基本的信息输出
c05.03 若干字符串和内存操作函数实现
c05.04 支持字符串的格式化
c05.05 支持整数的格式化
c05.06 打印异常的信息

int gdt_alloc_segment (uint32_t base, uint32_t limit, uint16_t attr) {
改成返回描述符的

c06.01 添加任务状态段
c06.02 任务的简单初始化
c06.03 双任务相互切换
c07.01 定义结点和链表
c07.02 链表的查询函数
c07.03 链表的两种插入
c07.04 链表的两种删除
c07.05 获取结点所在的结构

c08.01 添加任务管理器
c08.02 将任务加入就绪队列
c08.03 任务主动放弃CPU
c08.04 让任务按时间片运行 （时间片切换任务时输出会有问题，在log_print中）
c08.05 开关中断保护临界资源
c08.06 单个任务延时运行
c08.07 双任务延时运行

任务间同步与通信
c09.01 初始化信号量
c09.02 使用信号量进行任务同步
c09.03 互斥锁的初始化和锁定
c09.04 互斥锁的解锁
c09.05 字节FIFO的初始化
c09.06 字节FIFO的数据写入
c09.07 字节FIFO的数据读取

内存管理和保护
// 所有任务共享同一DPL3的代码和数据段，即Protected Flat Model
c10.01 位图数据结构简介与初始化
c10.02 位图位的分配
c10.03 实现地址分配结构
c10.04 规划内存空间的分配
c10.05 开启内存分页机制 (程序会跑飞，因为未在任务中设置页表，值为0，所以导致计算机重启。)
c10.06 创建内核页表(1)-建立映射表
c10.07 创建内核页表(2)-页目录和页表结构
c10.08 创建内核页表(3)-完成映射 (注意lds中要加对齐)
c10.09 为任务创建页表


// 切换至第一个用户进程
c11.01 创建初始进程程序  (通过readelf展示具体的init信息，说明加载地址和运行地址的区别)
c11.02 将初始进程搬运至指定位置 （不用搬运，用虚拟内存映射也是可以。这样用搬运好说明进程的一般运行机制）
c11.03 切换至用户特权级（切换后发现出现tripfault，执行到move %ss, %ax时，查看页表发现无用户权限, 设置。但后面发现仍然重启，没有原因tss->esp为0）
c11.04 为进程添加特权级0的栈空间(仍会死机，。。。因为调用了os内核区的代码sys_mslepp，没有权限访问。后面实现系统调用)
c11.05 修改空闲任务的特权级 (权限不能太低，方便执行特殊指令，同时避免被杀死)

// 系统调用框架的建立
c12.01 初试调用门的使用
c12.02 实现msleep系统调用
c12.03 实现getid系统调用
c12.04 实现sched_yield系统调用
c12.05 实现fork系统调用（1）- 添加调用接口
c12.06 实现fork系统调用（2）- 分配任务块
c12.07 实现fork系统调用（3）- 初始化任务块(子进程能跑，并返回到syscall调用中，但再次返回时跑飞，因为栈和父进程共用)
c12.08 实现fork系统调用（4) - 复制进程空间







