// boot实现
c03.01 计算机启动流程简介（无代码）
c03.02 接管计算机运行（无代码）
c03.03 创建可引导的启动程序
c03.04 初始化引导程序
c03.05 使用BIOS中断显示字符
c03.06 使用BIOS中断读取磁盘
c03.07 进入C语言环境并跳到loader

// loader实现
c04.01 利用内联汇编显示字符串
c04.02 检测内存信息
c04.03 切换至保护模式（1）
c04.04 切换至保护模式（2）
c04.05 使用LBA读取内核
c04.06 创建内核工程
c04.07 向内核传递参数
c04.08 代码/数据段与链接脚本
c04.09 加载内核映像文件(1)
c04.10 加载内核映像文件(2)

// 中断系统配置
c05.01 创建GDT表及其表项
c05.02 保护模式下的内存管理简介
c05.03 重新加载GDT
c05.04 触发运行中的异常（除0异常）
c05.05 添加门描述符定义
c05.06 初始化IDT表
c05.07 捕获除0异常
c05.08 利用栈解析异常栈中的参数
c05.09 模板化异常处理流程(利用宏)
c05.10 处理其它类型的所有异常
c05.11 初始化中断控制器
c05.12 中断的打开与关闭
c05.13 启动定时器并打开中断

// 字符串与格式化输出
c06.01 创建日志打印接口
c06.02 实现基本的信息输出
c06.03 字符串和内存工具函数实现
c06.04 实现字符串的格式化输出
c06.05 支持整数的格式化
c06.06 打印异常的信息
c06.07 断言与调试

// 实现简单的任务切换
c07.01 定义初始任务（待整理）
c07.02 添加任务状态段
c07.03 任务的简单初始化
c07.04 双任务相互切换
c07.05 另一种任务切换方法

// 重要的数据结构链表
c08.01 定义结点和链表
c08.02 链表的查询函数
c08.03 链表的两种插入
c08.04 链表的两种删除
c08.05 获取结点所在的结构

// 实现任务管理与延时
c09.01 添加任务管理器
c09.02 将任务加入就绪队列
c09.03 任务主动放弃CPU: task_yield()
c09.04 让任务按时间片运行 （时间片切换任务时输出会有问题，在log_print中。效果看不出来）
c09.05 临界资源及简单的保护
c09.06 为任务增加延时功能
c09.07 让所有任务都能延时(如果qemu长时间不在前台运行，可能会待机。vscode中任务输出会停止。将qemu放到前台后，输出将重新进行)

任务间同步与通信
c10.01 信号量介绍及其初始化
c10.02 使用信号量进行任务同步
c10.03 互斥锁介绍及其初始化
c10.04 互斥锁的加解锁
c10.05 使用互斥锁替换关中断 (可测试下时间片打印，看看有没有问题。可看到完全改变了执行流程，因为没有长时间占用一个设备，而是轮流使用，但对单个进程而言，他自己是不知道这点的）
c10.06 字节流管道的初始化
c10.07 数据写入字节流管道
c10.08 从字节流管道读取数

内存管理和保护模式
// 所有任务共享同一DPL3的代码和数据段，即Protected Flat Model
c11.00 存储管理概述
c11.01 位图数据结构与初始化
c11.02 位图位的分配
c11.03 实现地址分配结构
c11.04 规划内存空间的分配(在1MB空间中分配一个位图表，进行物理地址空间的分配)
c11.05 开启内存分页机制 (在loader中开启分页。程序会跑飞，因为未在任务tss设置页表，值为0，所以导致计算机重启。)
c11.06 创建内核页表(1)-建立映射表
c11.07 创建内核页表(2)-页目录和页表结构(主要是页目录表的定义)
c11.08 创建内核页表(3)-完成映射 (注意lds中要加对齐，否则会出现pte-present=1,仍然会死机)
c11.09 为任务创建页表(解决了死机重启的问题)

// 切换至第一个用户进程
c12.01 创建初始进程程序
c12.02 配置初始进程的加载地址和运行地址(通过readelf展示具体的init信息，说明加载地址和运行地址的区别)
c12.03 将初始进程搬运至指定位置 （不用搬运，用虚拟内存映射也是可以。这样用搬运好说明进程的一般运行机制）
c12.04 调整应用的特权级（切换发现出现page_fault，发现异常frame解析错误。因为切换至了idle_task，特权级3，不能使用特权级0的代码）
c12.05 调整异常处理函数(增加更详细的异常输出信息)
c12.06 修改空闲任务的特权级 (权限不能太低，方便执行特殊指令，同时避免被杀死)
c12.07 切换至用户特权级为最低(触发triple fault，两个原因：页面权限没设置为us，另外esp0没设置导致异常执行出问题)
c12.08 为进程添加特权级0的栈空间(去掉msleep和log_printf，否则仍会死机，。。。因为调用了os内核区的代码，没有权限访问)

// 建立系统调用
c13.01 创建一个调用门
c13.02 实现对调用门的调用和返回
c13.03 实现msleep系统调用
c13.04 实现getid系统调用
c13.05 增加log_printf调用(临时使用)

// 从磁盘加载程序运行
c14.01 实现fork系统调用（1）- 添加调用接口
c14.02 实现fork系统调用（2）- 分配任务块
c14.03 实现fork系统调用（3）- 初始化任务块(子进程能跑，并返回到syscall调用中，但再次返回时跑飞，因为栈和父进程共用)
c14.04 实现fork系统调用（4) - 复制进程空间
c14.05 实现sched_yield系统调用
c14.06 实现exec系统调用(1) - 创建一个空应用
c14.07 实现exec系统调用(2) - 增加空的exec调用
c14.08 实现exec系统调用(3) - 添加虚文件访问接口
c14.09 实现exec系统调用(4) - 解析并加载elf文件
c14.10 实现exec系统调用(5) - 分配栈并进入进程执行（调用main时会死机，因为argc，argv的地址在栈空间外，不存在，所以导致页出错。可观察出错地址在0xe000xxx开头）
c14.11 实现exec系统调用(6) - 为进程传递参数

// printf的实现（文件系统框架和字符设备驱动程序）
c15.01 添加文件系统调用
c15.02 测试printf系统调用
c15.03

// fat16文件系统的实现(简单且能在不同的系统上均可顺利挂载，后期高级扩展部分考虑增加对ext2文件系统的支持)
// 实现各项文件接口
c16.20 实现文件的读取和shell的加载
c16.21 stat文件信息的获取

// 命令行交互接口:提供几个基础的命令，后续可以让学生自己根据
c17: .。。。。。。

// 完善进程管理：wait和exit调用的实现
c18.21





